/* Includes ------------------------------------------------------------------*/

#include "FreeRTOS.h"
#include "task.h"
//#include "usbd_hid_core.h"
//#include "usbd_usr.h"
//#include "usbd_desc.h"

#include "main.h"
#include "stm32f4xx_conf.h"
#include "usart.h"
#include "queue.h"
#include "semphr.h"

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
#define TESTRESULT_ADDRESS         0x080FFFFC
#define ALLTEST_PASS               0x00000000
#define ALLTEST_FAIL               0x55555555
#define BUFFERSIZE 128
#define ADC1_DR_Address   ((uint32_t)0x4001204C)
#define STRING_PRESS 0x06
#define STRING_RELEASE 0x07
#define STRING_FRET 0x08
//For freting
#define fret_string1_left 345
#define fret_string1_right 435
#define fret_string2_left 435
#define fret_string2_right 345
#define fret_string3_left 305
#define fret_string3_right 395
#define fret_string4_left 950
#define fret_string4_right 700
#define fret_string5_left 335
#define fret_string5_right 415
#define fret_string6_left 450
#define fret_string6_right 330
/* For Pressing */
#define press_string1 360
#define press_string2 510
#define press_string3 485
#define press_string4 165
#define press_string5 500
#define press_string6 277
#define release_string1 300
#define release_string2 560
#define release_string3 580
#define release_string4 130
#define release_string5 450
#define release_string6 330
/* For Moving */
#define M_S1_G0 130
#define M_S1_G1 130
#define M_S1_G2 290
#define M_S1_G3 420
#define M_S1_G4 590
#define M_S2_G0 130
#define M_S2_G1 130
#define M_S2_G2 240
#define M_S2_G3 430
#define M_S2_G4 590
#define M_S3_G0 130
#define M_S3_G1 130
#define M_S3_G2 270
#define M_S3_G3 440
#define M_S3_G4 590

#define M_S4_G0 590
#define M_S4_G1 590
#define M_S4_G2 430
#define M_S4_G3 202
#define M_S4_G4 130
#define M_S5_G0 600 
#define M_S5_G1 600 
#define M_S5_G2 400
#define M_S5_G3 220
#define M_S5_G4 134
#define M_S6_G0 570
#define M_S6_G1 570
#define M_S6_G2 430
#define M_S6_G3 270
#define M_S6_G4 120

/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/

__IO uint32_t TimingDelay;
__IO uint8_t UserButtonPressed = 0x00;
static int move_map[6][5] = {{M_S1_G0,M_S1_G1,M_S1_G2,M_S1_G3,M_S1_G4}, 
                        {M_S2_G0, M_S2_G1, M_S2_G2, M_S2_G3, M_S2_G4}, 
                        {M_S3_G0, M_S3_G1, M_S3_G2, M_S3_G3, M_S3_G4}, 
                        {M_S4_G0, M_S4_G1, M_S4_G2, M_S4_G3, M_S4_G4}, 
                        {M_S5_G0, M_S5_G1, M_S5_G2, M_S5_G3, M_S5_G4}, 
                        {M_S6_G0, M_S6_G1, M_S6_G2, M_S6_G3, M_S6_G4}};
volatile xSemaphoreHandle serial_tx_wait_sem = NULL;
/* Add for serial input */
volatile xQueueHandle serial_rx_queue = NULL;

/* Private function prototypes -----------------------------------------------*/
static void interpreter_task(void *pvParameters);
void ServoControl_init_A();
void ServoControl_init_B();
void ServoControl_init_B_2();
void ServoControl_init_C();
void ServoControl_init_C_2();
void ServoControl_init_D();
void ServoControl_init_B_3();
void string_fret(int stringNum);
void string_move(int stringNum, int gridNum);
void string_press(int stringNum);
void string_release(int stringNum);
void string_chord(int first, int last);

/**
  * @brief  This function handles EXTI0_IRQ Handler.
  * @param  None
  * @retval None
  */
void EXTI0_IRQHandler(void)
{
  /* Clear the EXTI line pending bit */
  EXTI_ClearITPendingBit(USER_BUTTON_EXTI_LINE);
  if(UserButtonPressed){
    UserButtonPressed=0x00;
  }else
    UserButtonPressed=0x01;

}

void USART2_IRQHandler()
{
  static signed portBASE_TYPE xHigherPriorityTaskWoken;

  /* If this interrupt is for a transmit... */
  if (USART_GetITStatus(USART2, USART_IT_TXE) != RESET) {
    /* "give" the serial_tx_wait_sem semaphore to notfiy processes
     * that the buffer has a spot free for the next byte.
     */
    xSemaphoreGiveFromISR(serial_tx_wait_sem, &xHigherPriorityTaskWoken);

    /* Diables the transmit interrupt. */
    USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    /* If this interrupt is for a receive... */
  }else if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET){
    char msg = USART_ReceiveData(USART2);

    /* If there is an error when queueing the received byte, freeze! */
    if(!xQueueSendToBackFromISR(serial_rx_queue, &msg, &xHigherPriorityTaskWoken))
      while(1);
  }
  else {
    /* Only transmit and receive interrupts should be enabled.
     * If this is another type of interrupt, freeze.
     */
    while(1);
  }

  if (xHigherPriorityTaskWoken) {
    taskYIELD();
  }
}

void send_byte(char ch)
{
  /* Wait until the RS232 port can receive another byte (this semaphore
   * is "given" by the RS232 port interrupt when the buffer has room for
   * another byte.
   */
  while (!xSemaphoreTake(serial_tx_wait_sem, portMAX_DELAY));

  /* Send the byte and enable the transmit interrupt (it is disabled by
   * the interrupt).
   */
  USART_SendData(USART2, ch);
  USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
}

char recv_byte()
{
  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
  char msg;
  while(!xQueueReceive(serial_rx_queue, &msg, portMAX_DELAY));
  return msg;
}

void USART_puts(USART_TypeDef* USARTx, volatile char *s){

        while(*s){
                /*// wait until data register is empty
                while( !(USARTx->SR & 0x00000040) ); 

        USART_SendData(USARTx, *s);
                *s++;*/
    send_byte(*s++);
        }
}


void all_init(){
  string_release(3);
  vTaskDelay(100);
  string_release(4);
  vTaskDelay(100);
  string_release(5);
  vTaskDelay(100);
  string_move(3,1);
  vTaskDelay(100);
  string_move(4,1);
  vTaskDelay(100);
  string_move(5,1);
  vTaskDelay(500);
}

static void test_task(void *pvParameters)
{
  all_init();

  while(1){
    string_move(3,1);
    vTaskDelay(50);
    string_move(4,1);
    vTaskDelay(50);
    string_move(5,1);
    vTaskDelay(1000);
    string_press(3);
    vTaskDelay(50);
    string_press(4);
    vTaskDelay(50);
    string_press(5);
    vTaskDelay(1000);
    string_fret(3);
    vTaskDelay(50);
    string_fret(4);
    vTaskDelay(50);
    string_fret(5);
    vTaskDelay(1000);
    string_release(3);
    vTaskDelay(50);
    string_release(4);
    vTaskDelay(50);
    string_release(5);
    vTaskDelay(1000);

    string_move(3,2);
    vTaskDelay(50);
    string_move(4,2);
    vTaskDelay(50);
    string_move(5,2);
    vTaskDelay(1000);
    string_press(3);
    vTaskDelay(50);
    string_press(4);
    vTaskDelay(50);
    string_press(5);
    vTaskDelay(1000);
    string_fret(3);
    vTaskDelay(50);
    string_fret(4);
    vTaskDelay(50);
    string_fret(5);
    vTaskDelay(1000);
    string_release(3);
    vTaskDelay(50);
    string_release(4);
    vTaskDelay(50);
    string_release(5);
    vTaskDelay(1000);

    string_move(3,3);
    vTaskDelay(50);
    string_move(4,3);
    vTaskDelay(50);
    string_move(5,3);
    vTaskDelay(1000);
    string_press(3);
    vTaskDelay(50);
    string_press(4);
    vTaskDelay(50);
    string_press(5);
    vTaskDelay(1000);
    string_fret(3);
    vTaskDelay(50);
    string_fret(4);
    vTaskDelay(50);
    string_fret(5);
    vTaskDelay(1000);
    string_release(3);
    vTaskDelay(50);
    string_release(4);
    vTaskDelay(50);
    string_release(5);
    vTaskDelay(1000);

    string_move(3,4);
    vTaskDelay(50);
    string_move(4,4);
    vTaskDelay(50);
    string_move(5,4);
    vTaskDelay(1000);
    string_press(3);
    vTaskDelay(50);
    string_press(4);
    vTaskDelay(50);
    string_press(5);
    vTaskDelay(1000);
    string_fret(3);
    vTaskDelay(50);
    string_fret(4);
    vTaskDelay(50);
    string_fret(5);
    vTaskDelay(1000);
    string_release(3);
    vTaskDelay(50);
    string_release(4);
    vTaskDelay(50);
    string_release(5);
    vTaskDelay(1000);
  }
}

static void interpreter_task(void *pvParameters)
{
  init_USART();

  char opcode;
  
  while(1){
    /*Assume we can complete all task in O(1)*/
#ifdef TX_DEBUG
    USART_puts(USART2, "Connect Success!\r\n");
#endif
    opcode = recv_byte();
    switch(opcode%16){ 
      case STRING_PRESS:    /* 0x06 */

#ifdef TX_DEBUG        
        USART_puts(USART2, "Operation: press\r\n");
#endif
        string_press(opcode/16); break;
      case STRING_RELEASE:  /* 0x07 */
#ifdef TX_DEBUG
        USART_puts(USART2, "Operation: release\r\n");
#endif
        string_release(opcode/16); break;
      case STRING_FRET:     /* 0x08 */
#ifdef TX_DEBUG
        USART_puts(USART2, "Operation: fret\r\n");
#endif
        string_fret(opcode/16); break;
      default:
        if(opcode % 16 >= 0x0 && opcode % 16 <= 0x5){
#ifdef TX_DEBUG
          USART_puts(USART2, "Operation: move\r\n");
#endif
          string_move(opcode/16, opcode%16);
        }
        else{
          if(opcode/16 >= 0xA && opcode/16 <= 0xF && opcode % 16 >= 0xA && opcode % 16 <= 0xF){
            string_chord(opcode/16-0xA, opcode%16-0xA);
#ifdef TX_DEBUG
            USART_puts(USART2, "Operation: chord\r\n");
#endif
          }
#ifdef TX_DEBUG
          else
            USART_puts(USART2, "Invaild operation\r\n");
#endif
        }
        break;
    }
  }
}

int main(void)
{
  RCC_ClocksTypeDef RCC_Clocks;
  
  /* Configure SysTick */
  RCC_GetClocksFreq(&RCC_Clocks);
  //SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);

  FLASH_ProgramWord(TESTRESULT_ADDRESS, ALLTEST_PASS);
  SystemInit();
  //while(TimingDelay);


  /* Initialize LEDs and User_Button on STM32F4-Discovery --------------------*/
  STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI);

  /* Initialize LEDs to be managed by GPIO */
  STM_EVAL_LEDInit(LED4);
  STM_EVAL_LEDInit(LED3);
  STM_EVAL_LEDInit(LED5);
  STM_EVAL_LEDInit(LED6);

  /* Reset UserButton_Pressed variable */
  UserButtonPressed = 0x00;

  /* Initial Servo Control */
  ServoControl_init_A();
  ServoControl_init_B();
  ServoControl_init_B_2();
  ServoControl_init_B_3();
  ServoControl_init_C();
  ServoControl_init_C_2();
  ServoControl_init_D();

  /* Create the queue used by the serial task.  Messages for write to
         * the RS232. */
        vSemaphoreCreateBinary(serial_tx_wait_sem);
        /* Add for serial input 
         * Reference: www.freertos.org/a00116.html */
        serial_rx_queue = xQueueCreate(100, sizeof(char));

  /* Create a task to button check. */
  xTaskCreate(interpreter_task,
             (signed portCHAR *) "Guitar task",
             512 /* stack size */, NULL,
             tskIDLE_PRIORITY + 5, NULL);

  /* Start running the tasks. */
  vTaskStartScheduler(); 

  return 0;
}

void fret_position_init(){
  TIM2->CCR3 = fret_string1_left;
  TIM12->CCR1 = fret_string2_left;
  TIM12->CCR2 = fret_string3_left;
  TIM10->CCR1 = fret_string4_left;
  TIM11->CCR1 = fret_string5_left;
  TIM2->CCR4 = fret_string6_left;
}

void servo_folk(){
  while(1){
    string_chord(6,1);
    vTaskDelay(150);
    string_chord(6,1);
    vTaskDelay(75);
    string_chord(1,6);
    vTaskDelay(150);
    string_chord(1,6);
    vTaskDelay(75);
    string_chord(6,1);
    vTaskDelay(75);
    string_chord(1,6);
    vTaskDelay(75);
  }
}

void string_fret(int stringNum){
  switch(stringNum){
    case 0:
      if(TIM3->CCR1 == fret_string1_left)
        TIM3->CCR1 = fret_string1_right;
      else
        TIM3->CCR1 = fret_string1_left;
      break;
    case 1:
      if(TIM12->CCR1 == fret_string2_left)
        TIM12->CCR1 = fret_string2_right;
      else
        TIM12->CCR1 = fret_string2_left;
      break;
    case 2:
      if(TIM12->CCR2 == fret_string3_left)
        TIM12->CCR2 = fret_string3_right;
      else
        TIM12->CCR2 = fret_string3_left;
      break;
    case 3:
      if(TIM10->CCR1 == fret_string4_left)
        TIM10->CCR1 = fret_string4_right;
      else
        TIM10->CCR1 = fret_string4_left;
      break;
    case 4:
      if(TIM11->CCR1 == fret_string5_left)
        TIM11->CCR1 = fret_string5_right;
      else
        TIM11->CCR1 = fret_string5_left;
      break;
    case 5:
      if(TIM3->CCR2 == fret_string6_left)
        TIM3->CCR2 = fret_string6_right;
      else
        TIM3->CCR2 = fret_string6_left;
      break;
    default:
      break;
    }
}

void string_move(int stringNum, int gridNum){
  switch(stringNum){
    case 3:
      if(TIM4->CCR1 == move_map[stringNum][gridNum]);
      else
        TIM4->CCR1 = move_map[stringNum][gridNum];
      break;
    case 4:
      if(TIM4->CCR2 == move_map[stringNum][gridNum]);
      else
        TIM4->CCR2 = move_map[stringNum][gridNum];
      break;
    case 5:
      if(TIM4->CCR3 == move_map[stringNum][gridNum]);
      else
        TIM4->CCR3 = move_map[stringNum][gridNum];
      break;
    default:
      break;
  }
}

void string_press(int stringNum){
  switch(stringNum){
    case 3:
      TIM4->CCR4 = press_string4;
      break;
    case 4:
      TIM3->CCR3 = press_string5;
      break;
    case 5:
      TIM3->CCR4 = press_string6;
      break;
    default:
      break;
  }
}

void string_release(int stringNum){
  switch(stringNum){
    case 3:
      TIM4->CCR4 = release_string4;
      break;
    case 4:
      TIM3->CCR3 = release_string5;
      break;
    case 5:
      TIM3->CCR4 = release_string6;
      break;
    default:
      break;
  }
}

//c is between a and b, ie. c contains in [a, b] ??
#define between(c, a, b) (((a)<=(c)&&(c)<=(b))||((a)>=(c)&&(c)>=(b)))
void string_chord(int first, int last){
  int string_count;
  for (string_count = first;between(string_count, first, last); string_count+=((first<last)?1:-1))
  {
    string_fret(string_count);
    vTaskDelay(5);
  }
}

void servo_push(){
  while(1){
    string_release(1);
    vTaskDelay(500);
    string_press(1);
    vTaskDelay(1000);
  }    
}

void ServoControl_init_A(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOA , ENABLE );
  RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM2, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_TIM2);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_TIM2);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_2 | GPIO_Pin_3;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOA, &GPIO_InitStructure );  
      
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 336 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM2, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;

  TIM_OC3Init( TIM2, &TIM_OCInitStruct );
  TIM_OC4Init( TIM2, &TIM_OCInitStruct );

  TIM_Cmd( TIM2, ENABLE );
}

void ServoControl_init_B(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOB , ENABLE );
  RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM3, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOB, GPIO_PinSource0, GPIO_AF_TIM3);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource1, GPIO_AF_TIM3);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_TIM3);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_TIM3);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOB, &GPIO_InitStructure );  
      
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 336 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM3, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;

  TIM_OC1Init( TIM3, &TIM_OCInitStruct );
  TIM_OC2Init( TIM3, &TIM_OCInitStruct );
  TIM_OC3Init( TIM3, &TIM_OCInitStruct );
  TIM_OC4Init( TIM3, &TIM_OCInitStruct );

  TIM_Cmd( TIM3, ENABLE );
}

void ServoControl_init_B_2(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOB , ENABLE );
  RCC_APB2PeriphClockCmd( RCC_APB2Periph_TIM11, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOB, GPIO_PinSource9, GPIO_AF_TIM11);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_9; //| GPIO_Pin_15; //PD12->LED3 PD13->LED4 PD14->LED5 PDa5->LED6
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOB, &GPIO_InitStructure );  
      
  // Let PWM frequency equal 100Hz.
  // Let period equal 1000. Therefore, timer runs from zero to 1000. Gives 0.1Hz resolution.
  // Solving for prescaler gives 240.
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 632 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM11, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;

  TIM_OC1Init( TIM11, &TIM_OCInitStruct );

  TIM_Cmd( TIM11, ENABLE );
}

void ServoControl_init_B_3(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOB , ENABLE );
  RCC_APB2PeriphClockCmd( RCC_APB2Periph_TIM10, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOB, GPIO_PinSource8, GPIO_AF_TIM10);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8; //| GPIO_Pin_15; //PD12->LED3 PD13->LED4 PD14->LED5 PDa5->LED6
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOB, &GPIO_InitStructure );  
      
  // Let PWM frequency equal 100Hz.
  // Let period equal 1000. Therefore, timer runs from zero to 1000. Gives 0.1Hz resolution.
  // Solving for prescaler gives 240.
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 336 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM10, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;

  TIM_OC1Init( TIM10, &TIM_OCInitStruct );
  TIM_OC2Init( TIM10, &TIM_OCInitStruct );

  TIM_Cmd( TIM10, ENABLE );
}

void ServoControl_init_C(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOB , ENABLE );
  RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM12, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOB, GPIO_PinSource14, GPIO_AF_TIM12);
  GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_TIM12);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_14 | GPIO_Pin_15;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOB, &GPIO_InitStructure );  
      
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 336 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM12, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;

  TIM_OC1Init( TIM12, &TIM_OCInitStruct );
  TIM_OC2Init( TIM12, &TIM_OCInitStruct );

  TIM_Cmd( TIM12, ENABLE );
}

void ServoControl_init_C_2(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOC , ENABLE );
  RCC_APB1PeriphClockCmd( RCC_APB2Periph_TIM8, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_TIM8);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_TIM8);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_6 | GPIO_Pin_7;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOC, &GPIO_InitStructure );  
      
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 336 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM8, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM2;

  TIM_OC1Init( TIM8, &TIM_OCInitStruct );
  TIM_OC2Init( TIM8, &TIM_OCInitStruct );

  TIM_Cmd( TIM8, ENABLE );
}

void ServoControl_init_D(){
  RCC_AHB1PeriphClockCmd(  RCC_AHB1Periph_GPIOD , ENABLE );
  RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM4, ENABLE );

  GPIO_InitTypeDef GPIO_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
  TIM_OCInitTypeDef TIM_OCInitStruct;
    
  GPIO_StructInit(&GPIO_InitStructure); // Reset init structure

  GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_TIM4);
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_TIM4);
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_TIM4);
  GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_TIM4);
    
  // Setup Blue & Green LED on STM32-Discovery Board to use PWM.
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15; //| GPIO_Pin_15; //PD12->LED3 PD13->LED4 PD14->LED5 PDa5->LED6
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;            // Alt Function - Push Pull
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_Init( GPIOD, &GPIO_InitStructure );  
      
  // Let PWM frequency equal 100Hz.
  // Let period equal 1000. Therefore, timer runs from zero to 1000. Gives 0.1Hz resolution.
  // Solving for prescaler gives 240.
  TIM_TimeBaseStructInit( &TIM_TimeBaseInitStruct );
  TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV4;
  TIM_TimeBaseInitStruct.TIM_Period = 10000 - 1;   // 0..2999
  TIM_TimeBaseInitStruct.TIM_Prescaler = 336 - 1; // Div 240   500  0.00002 s  =  0.2ms
  TIM_TimeBaseInit( TIM4, &TIM_TimeBaseInitStruct );

  TIM_OCStructInit( &TIM_OCInitStruct );
  TIM_OCInitStruct.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;

  TIM_OC1Init( TIM4, &TIM_OCInitStruct );
  TIM_OC2Init( TIM4, &TIM_OCInitStruct );
  TIM_OC3Init( TIM4, &TIM_OCInitStruct );
  TIM_OC4Init( TIM4, &TIM_OCInitStruct );

  TIM_Cmd( TIM4, ENABLE );
}

/**
  * @brief  This function handles the test program fail.
  * @param  None
  * @retval None
  */
void Fail_Handler(void)
{
  /* Erase last sector */ 
  FLASH_EraseSector(FLASH_Sector_11, VoltageRange_3);
  /* Write FAIL code at last word in the flash memory */
  FLASH_ProgramWord(TESTRESULT_ADDRESS, ALLTEST_FAIL);
  
  while(1)
  {
    /* Toggle Red LED */
    STM_EVAL_LEDToggle(LED5);
    vTaskDelay(5);
  }
}


void vApplicationTickHook()
{
}
